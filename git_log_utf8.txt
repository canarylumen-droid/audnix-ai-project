commit 356e7af119ce98272cbd571659905c80cc3ed684
Author: beliver-cell <fortuneuchendu708@gmail.com>
Date:   Fri Feb 27 03:21:36 2026 -0800

    Fix KPI data recovery, inbox filtering, and AI intent tracking permanence

diff --git a/server/drizzle-storage.ts b/server/drizzle-storage.ts
index c2d99e8..95e8cf0 100644
--- a/server/drizzle-storage.ts
+++ b/server/drizzle-storage.ts
@@ -440,46 +440,6 @@ export class DrizzleStorage implements IStorage {
     return result;
   }
 
-  async getLeadRank(leadId: string, userId: string): Promise<{ rank: number; total: number }> {
-    checkDatabase();
-    
-    // Get the target lead's score
-    const lead = await this.getLead(leadId);
-    if (!lead || lead.userId !== userId) {
-      return { rank: 0, total: 0 };
-    }
-    
-    const leadScore = lead.score || 0;
-    
-    // Count leads with higher scores
-    const [rankResult] = await db
-      .select({ count: sql<number>`count(*)` })
-      .from(leads)
-      .where(
-        and(
-          eq(leads.userId, userId),
-          eq(leads.archived, false),
-          sql`${leads.score} > ${leadScore}`
-        )
-      );
-      
-    // Count total active leads
-    const [totalResult] = await db
-      .select({ count: sql<number>`count(*)` })
-      .from(leads)
-      .where(
-        and(
-          eq(leads.userId, userId),
-          eq(leads.archived, false)
-        )
-      );
-      
-    const rank = Number(rankResult?.count || 0) + 1;
-    const total = Number(totalResult?.count || 0);
-    
-    return { rank, total };
-  }
-
 
   async createLead(insertLead: Partial<InsertLead> & { userId: string; name: string; channel: string }, options?: { suppressNotification?: boolean }): Promise<Lead> {
     checkDatabase();
@@ -1633,6 +1593,7 @@ export class DrizzleStorage implements IStorage {
     const [messagesStats] = await db.select({
       totalSent: sql<number>`count(*) filter (where direction = 'outbound')`,
       opened: sql<number>`count(*) filter (where direction = 'outbound' and opened_at is not null)`,
+      replied: sql<number>`count(*) filter (where direction = 'inbound')`,
       messagesToday: sql<number>`count(*) filter (where ${messages.createdAt} >= ${todayStart} and direction = 'outbound')`,
       messagesYesterday: sql<number>`count(*) filter (where ${messages.createdAt} >= ${yesterdayStart} and ${messages.createdAt} < ${todayStart} and direction = 'outbound')`,
       positiveIntents: sql<number>`count(*) filter (where direction = 'inbound' and (lower(body) like '%yes%' or lower(body) like '%book%' or lower(body) like '%interested%' or lower(body) like '%call%' or lower(body) like '%meeting%'))`,
@@ -1661,7 +1622,7 @@ export class DrizzleStorage implements IStorage {
     const averageResponseTime = await this.calculateAverageResponseTime(userId);
 
     return {
-      totalLeads,
+      totalLeads: Number(leadsStats?.totalLeads || 0),
       newLeads: Number(leadsStats?.newLeads || 0),
       activeLeads: Number(leadsStats?.activeLeads || 0),
       convertedLeads: Number(leadsStats?.convertedLeads || 0),
@@ -1669,13 +1630,13 @@ export class DrizzleStorage implements IStorage {
       bouncyLeads: Number(leadsStats?.bouncyLeads || 0),
       recoveredLeads: Number(leadsStats?.recoveredLeads || 0),
       positiveIntents: Number(messagesStats?.positiveIntents || 0),
-      totalMessages: totalSent,
+      totalMessages: Number(messagesStats?.totalSent || 0),
       messagesToday: Number(messagesStats?.messagesToday || 0),
       messagesYesterday: Number(messagesStats?.messagesYesterday || 0),
       pipelineValue: Number(dealsStats?.pipelineValue || 0) + Number(predictedStats?.value || 0),
       closedRevenue: Number(dealsStats?.closedRevenue || 0),
-      openRate: totalSent > 0 ? Math.round((opened / totalSent) * 100) : 0,
-      responseRate: totalLeads > 0 ? Math.round((replied / totalLeads) * 100) : 0,
+      openRate: Number(messagesStats?.totalSent || 0) > 0 ? Math.round((Number(messagesStats?.opened || 0) / Number(messagesStats?.totalSent || 0)) * 100) : 0,
+      responseRate: Number(leadsStats?.totalLeads || 0) > 0 ? Math.round((Number(messagesStats?.replied || 0) / Number(leadsStats?.totalLeads || 0)) * 100) : 0,
       averageResponseTime,
       queuedLeads: Number(leadsStats?.queuedLeads || 0),
       undeliveredLeads: Number(leadsStats?.bouncyLeads || 0),

commit faffba577278469f7f6fec3cf720173393a40820
Author: beliver-cell <fortuneuchendu708@gmail.com>
Date:   Thu Feb 26 11:49:46 2026 -0800

    feat: refine lead intelligence, absolute ranking, social insights, and dashboard UI

diff --git a/server/drizzle-storage.ts b/server/drizzle-storage.ts
index 2009704..c2d99e8 100644
--- a/server/drizzle-storage.ts
+++ b/server/drizzle-storage.ts
@@ -440,6 +440,46 @@ export class DrizzleStorage implements IStorage {
     return result;
   }
 
+  async getLeadRank(leadId: string, userId: string): Promise<{ rank: number; total: number }> {
+    checkDatabase();
+    
+    // Get the target lead's score
+    const lead = await this.getLead(leadId);
+    if (!lead || lead.userId !== userId) {
+      return { rank: 0, total: 0 };
+    }
+    
+    const leadScore = lead.score || 0;
+    
+    // Count leads with higher scores
+    const [rankResult] = await db
+      .select({ count: sql<number>`count(*)` })
+      .from(leads)
+      .where(
+        and(
+          eq(leads.userId, userId),
+          eq(leads.archived, false),
+          sql`${leads.score} > ${leadScore}`
+        )
+      );
+      
+    // Count total active leads
+    const [totalResult] = await db
+      .select({ count: sql<number>`count(*)` })
+      .from(leads)
+      .where(
+        and(
+          eq(leads.userId, userId),
+          eq(leads.archived, false)
+        )
+      );
+      
+    const rank = Number(rankResult?.count || 0) + 1;
+    const total = Number(totalResult?.count || 0);
+    
+    return { rank, total };
+  }
+
 
   async createLead(insertLead: Partial<InsertLead> & { userId: string; name: string; channel: string }, options?: { suppressNotification?: boolean }): Promise<Lead> {
     checkDatabase();
@@ -1309,11 +1349,11 @@ export class DrizzleStorage implements IStorage {
 
     const [mainSummary] = await db.select({
       totalLeads: sql<number>`count(*)`,
-      conversions: sql<number>`count(*) filter (where status = 'converted')`,
-      active: sql<number>`count(*) filter (where status in ('open', 'replied'))`,
+      conversions: sql<number>`count(*) filter (where status in ('converted', 'booked'))`,
+      active: sql<number>`count(*) filter (where status in ('open', 'replied', 'warm'))`,
       ghosted: sql<number>`count(*) filter (where status = 'cold')`,
       notInterested: sql<number>`count(*) filter (where status = 'not_interested')`,
-      leadsReplied: sql<number>`count(*) filter (where status in ('replied', 'converted'))`,
+      leadsReplied: sql<number>`count(*) filter (where status in ('replied', 'converted', 'booked', 'warm'))`,
     })
       .from(leads)
       .where(and(eq(leads.userId, userId), gte(leads.createdAt, startDate)));
@@ -1347,7 +1387,7 @@ export class DrizzleStorage implements IStorage {
     const timelineResults = await db.select({
       date: sql<string>`to_char(created_at, 'YYYY-MM-DD')`,
       leads: sql<number>`count(*)`,
-      conversions: sql<number>`count(*) filter (where status = 'converted')`,
+      conversions: sql<number>`count(*) filter (where status in ('converted', 'booked'))`,
     })
       .from(leads)
       .where(and(eq(leads.userId, userId), gte(leads.createdAt, startDate)))
@@ -1359,7 +1399,7 @@ export class DrizzleStorage implements IStorage {
 
     // Sentiment calculation
     const [sentimentSummary] = await db.select({
-      positive: sql<number>`count(*) filter (where status in ('replied', 'converted', 'open'))`,
+      positive: sql<number>`count(*) filter (where status in ('replied', 'converted', 'booked', 'open', 'warm'))`,
       negative: sql<number>`count(*) filter (where status in ('not_interested', 'cold'))`,
     })
       .from(leads)
@@ -1580,8 +1620,8 @@ export class DrizzleStorage implements IStorage {
     const [leadsStats] = await db.select({
       totalLeads: sql<number>`count(*)`,
       newLeads: sql<number>`count(*) filter (where ${leads.createdAt} >= ${sevenDaysAgo})`,
-      activeLeads: sql<number>`count(*) filter (where status in ('open', 'replied'))`,
-      convertedLeads: sql<number>`count(*) filter (where status = 'converted')`,
+      activeLeads: sql<number>`count(*) filter (where status in ('open', 'replied', 'warm'))`,
+      convertedLeads: sql<number>`count(*) filter (where status in ('converted', 'booked'))`,
       hardenedLeads: sql<number>`count(*) filter (where verified = true)`,
       bouncyLeads: sql<number>`count(*) filter (where status = 'bouncy')`,
       recoveredLeads: sql<number>`count(*) filter (where status = 'recovered')`,
@@ -1618,10 +1658,7 @@ export class DrizzleStorage implements IStorage {
         sql`not exists (select 1 from deals where deals.lead_id = leads.id)`
       ));
 
-    const totalSent = Number(messagesStats?.totalSent || 0);
-    const totalLeads = Number(leadsStats?.totalLeads || 0);
-    const opened = Number(messagesStats?.opened || 0);
-    const replied = Number(leadsStats?.convertedLeads || 0) + Number(leadsStats?.activeLeads || 0); // Leads that engaged
+    const averageResponseTime = await this.calculateAverageResponseTime(userId);
 
     return {
       totalLeads,
@@ -1639,12 +1676,47 @@ export class DrizzleStorage implements IStorage {
       closedRevenue: Number(dealsStats?.closedRevenue || 0),
       openRate: totalSent > 0 ? Math.round((opened / totalSent) * 100) : 0,
       responseRate: totalLeads > 0 ? Math.round((replied / totalLeads) * 100) : 0,
-      averageResponseTime: '—', // TODO: Implement calculation for Drizzle
+      averageResponseTime,
       queuedLeads: Number(leadsStats?.queuedLeads || 0),
       undeliveredLeads: Number(leadsStats?.bouncyLeads || 0),
     };
   }
 
+  private async calculateAverageResponseTime(userId: string): Promise<string> {
+    const [responseTimeResult] = await db.execute(sql`
+      WITH response_times AS (
+        SELECT 
+          m2.created_at - m1.created_at as duration
+        FROM messages m1
+        JOIN messages m2 ON m1.lead_id = m2.lead_id
+        WHERE m1.direction = 'outbound'
+          AND m2.direction = 'inbound'
+          AND m2.created_at > m1.created_at
+          AND m1.user_id = ${userId}
+          AND NOT EXISTS (
+            SELECT 1 FROM messages m3
+            WHERE m3.lead_id = m1.lead_id
+              AND m3.created_at > m1.created_at
+              AND m3.created_at < m2.created_at
+          )
+      )
+      SELECT 
+        AVG(EXTRACT(EPOCH FROM duration)) as avg_seconds
+      FROM response_times
+    `);
+
+    const avgSeconds = Number((responseTimeResult as any)?.avg_seconds || 0);
+    if (avgSeconds <= 0) return '—';
+    
+    if (avgSeconds < 3600) {
+      return `${Math.round(avgSeconds / 60)}m`;
+    } else if (avgSeconds < 86400) {
+      return `${(avgSeconds / 3600).toFixed(1)}h`;
+    } else {
+      return `${(avgSeconds / 86400).toFixed(1)}d`;
+    }
+  }
+
   async getAnalyticsFull(userId: string, days: number): Promise < {
     metrics: {
       sent: number;
@@ -1676,8 +1748,8 @@ export class DrizzleStorage implements IStorage {
     // 1. Basic Metrics
     const [counts] = await db.select({
       totalLeads: sql<number>`count(*)`,
-      conversions: sql<number>`count(*) filter (where status = 'converted')`,
-      replied: sql<number>`count(*) filter (where status in ('replied', 'converted'))`,
+      conversions: sql<number>`count(*) filter (where status in ('converted', 'booked'))`,
+      replied: sql<number>`count(*) filter (where status in ('replied', 'converted', 'booked', 'warm'))`,
     }).from(leads).where(eq(leads.userId, userId));
 
     const [msgCounts] = await db.select({
@@ -1709,6 +1781,7 @@ export class DrizzleStorage implements IStorage {
     const replied = Number(counts?.replied || 0);
     const sent = Number(msgCounts?.sent || 0);
     const opened = Number(msgCounts?.opened || 0);
+    const averageResponseTime = await this.calculateAverageResponseTime(userId);
 
     // 2. Time Series
     // We'll calculate this in JS loop but using targeted SQL counts to avoid loading all objects
@@ -1729,9 +1802,9 @@ export class DrizzleStorage implements IStorage {
       }).from(messages).where(and(eq(messages.userId, userId), gte(messages.createdAt, dayStart), lte(messages.createdAt, dayEnd)));
 
       const [dayLeads] = await db.select({
-        replied_email: sql<number>`count(*) filter (where status in ('replied', 'converted') and channel = 'email')`,
-        replied_instagram: sql<number>`count(*) filter (where status in ('replied', 'converted') and channel = 'instagram')`,
-        booked: sql<number>`count(*) filter (where status = 'converted')`
+        replied_email: sql<number>`count(*) filter (where status in ('replied', 'converted', 'booked', 'warm') and channel = 'email')`,
+        replied_instagram: sql<number>`count(*) filter (where status in ('replied', 'converted', 'booked', 'warm') and channel = 'instagram')`,
+        booked: sql<number>`count(*) filter (where status in ('converted', 'booked'))`
       }).from(leads).where(and(eq(leads.userId, userId), gte(leads.updatedAt, dayStart), lte(leads.updatedAt, dayEnd)));
 
       timeSeries.push({
@@ -1776,7 +1849,7 @@ export class DrizzleStorage implements IStorage {
         openRate: sent > 0 ? Math.round((opened / sent) * 100) : 0,
         closedRevenue: Number(dealsStats?.closedRevenue || 0),
         pipelineValue: Number(dealsStats?.pipelineValue || 0) + Number(predictedStats?.value || 0),
-        averageResponseTime: '—' 
+        averageResponseTime: averageResponseTime
       },
       timeSeries,
       channelPerformance: channelStats.map((s: any) => ({ channel: s.channel || 'Unknown', value: Number(s.value) })),

commit e0109c95875122580a6ca9304f39acb71085d27e
Author: beliver-cell <fortuneuchendu708@gmail.com>
Date:   Wed Feb 25 13:52:46 2026 -0800

    fix: resolve frontend typescript errors and dashboard runtime crash
    
    - Fixed DashboardLayout.tsx runtime error by renaming notificationsOpen to showNotificationsPanel (addressing global scope conflict)
    - Unified pipelineValue calculation in storage.ts and drizzle-storage.ts to include AI-predicted deal values
    - Resolved TypeScript errors in analytics.tsx, home.tsx, LeadIntelligenceModal.tsx, and integrations.tsx
    - Ensured zero build errors across the project

diff --git a/server/drizzle-storage.ts b/server/drizzle-storage.ts
index 1e08e51..2009704 100644
--- a/server/drizzle-storage.ts
+++ b/server/drizzle-storage.ts
@@ -1552,6 +1552,7 @@ export class DrizzleStorage implements IStorage {
     closedRevenue: number;
     openRate: number;
     responseRate: number;
+    averageResponseTime: string;
     queuedLeads: number;
     undeliveredLeads: number;
   }> {
@@ -1606,6 +1607,17 @@ export class DrizzleStorage implements IStorage {
       .from(deals)
       .where(dealsBaseWhere);
 
+    // Calculate predicted deal value from leads without explicit deals
+    const [predictedStats] = await db.select({
+      value: sql<number>`coalesce(sum(cast(metadata->'intelligence'->'predictions'->>'predictedAmount' as numeric)), 0)`
+    })
+      .from(leads)
+      .where(and(
+        leadsBaseWhere,
+        sql`metadata->'intelligence'->'predictions'->>'predictedAmount' is not null`,
+        sql`not exists (select 1 from deals where deals.lead_id = leads.id)`
+      ));
+
     const totalSent = Number(messagesStats?.totalSent || 0);
     const totalLeads = Number(leadsStats?.totalLeads || 0);
     const opened = Number(messagesStats?.opened || 0);
@@ -1623,16 +1635,17 @@ export class DrizzleStorage implements IStorage {
       totalMessages: totalSent,
       messagesToday: Number(messagesStats?.messagesToday || 0),
       messagesYesterday: Number(messagesStats?.messagesYesterday || 0),
-      pipelineValue: Number(dealsStats?.pipelineValue || 0),
+      pipelineValue: Number(dealsStats?.pipelineValue || 0) + Number(predictedStats?.value || 0),
       closedRevenue: Number(dealsStats?.closedRevenue || 0),
       openRate: totalSent > 0 ? Math.round((opened / totalSent) * 100) : 0,
       responseRate: totalLeads > 0 ? Math.round((replied / totalLeads) * 100) : 0,
+      averageResponseTime: '—', // TODO: Implement calculation for Drizzle
       queuedLeads: Number(leadsStats?.queuedLeads || 0),
       undeliveredLeads: Number(leadsStats?.bouncyLeads || 0),
     };
   }
 
-  async getAnalyticsFull(userId: string, days: number): Promise<{
+  async getAnalyticsFull(userId: string, days: number): Promise < {
     metrics: {
       sent: number;
       opened: number;
@@ -1642,6 +1655,9 @@ export class DrizzleStorage implements IStorage {
       conversionRate: number;
       responseRate: number;
       openRate: number;
+      closedRevenue: number;
+      pipelineValue: number;
+      averageResponseTime: string;
     };
     timeSeries: Array<{
       name: string;
@@ -1668,6 +1684,21 @@ export class DrizzleStorage implements IStorage {
       sent: sql<number>`count(*) filter (where direction = 'outbound')`,
       opened: sql<number>`count(*) filter (where direction = 'outbound' and opened_at is not null)`,
     }).from(messages).where(eq(messages.userId, userId));
+    
+    const [dealsStats] = await db.select({
+      pipelineValue: sql<number>`coalesce(sum(value), 0)`,
+      closedRevenue: sql<number>`coalesce(sum(case when status = 'closed_won' then value else 0 end), 0)`,
+    }).from(deals).where(eq(deals.userId, userId));
+
+    const [predictedStats] = await db.select({
+      value: sql<number>`coalesce(sum(cast(metadata->'intelligence'->'predictions'->>'predictedAmount' as numeric)), 0)`
+    })
+      .from(leads)
+      .where(and(
+        eq(leads.userId, userId),
+        sql`metadata->'intelligence'->'predictions'->>'predictedAmount' is not null`,
+        sql`not exists (select 1 from deals where deals.lead_id = leads.id)`
+      ));
 
     const [user] = await db.select({
       filteredLeadsCount: users.filteredLeadsCount
@@ -1742,7 +1773,10 @@ export class DrizzleStorage implements IStorage {
         leadsFiltered: user?.filteredLeadsCount || 0,
         conversionRate: totalLeads > 0 ? Math.round((conversions / totalLeads) * 100) : 0,
         responseRate: totalLeads > 0 ? Math.round((replied / totalLeads) * 100) : 0,
-        openRate: sent > 0 ? Math.round((opened / sent) * 100) : 0
+        openRate: sent > 0 ? Math.round((opened / sent) * 100) : 0,
+        closedRevenue: Number(dealsStats?.closedRevenue || 0),
+        pipelineValue: Number(dealsStats?.pipelineValue || 0) + Number(predictedStats?.value || 0),
+        averageResponseTime: '—' 
       },
       timeSeries,
       channelPerformance: channelStats.map((s: any) => ({ channel: s.channel || 'Unknown', value: Number(s.value) })),
